---
layout: mypost
title: Repo
categories: [repo]
---
# Repo

Android 使用 Git 作为代码管理工具，开发了 Gerrit 进行代码审核以便更好的对代码进行集中式管理，还开发了 Repo 命令行工具，对 Git 部分命令封装，将百多个 Git 库有效的进行组织。

## 清单库

所谓的清单库，就是我们为manifest文件单独建的一个库，一个清单库可以包含多个清单文件和多个分支，每个清单文件和分支都有对应的版本。我们就是根据不同的manifest文件来下载不同的代码。

## 安装repo

在ubuntu中可以通过命令进行repo的安装：

    Sudo apt-get install repo

也可以直接下载repo文件，然后将路径配置到环境变量里面。

    $ mkdir ~/bin
    $ PATH=~/bin:$PATH
    $ curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo
    $ chmod a+x ~/bin/repo

## repo help

安装 Repo 后，您可以通过运行以下命令找到最新文档（开头是包含所有命令的摘要）：

    repo help

您可以通过在 Repo 树中运行以下命令来获取有关某个命令的信息：
    
    repo help <COMMAND>

例如，以下命令会生成 Repo init 参数的说明和选项列表，该参数会在当前目录中初始化 Repo。（要了解详情，请参阅 init。）

    repo help init
    
## repo init

Usage
    
    repo init -u URL [OPTIONS]

在当前目录中安装 Repo。这会创建一个 .repo/ 目录，其中包含用于 Repo 源代码和标准 Android 清单文件的 Git 代码库。该 .repo/ 目录中还包含 manifest.xml，这是一个指向 .repo/manifests/ 目录中所选清单的符号链接。

Options:

- u：指定一个URL，其连接到一个manifest仓库
- m：在manifest仓库中选择一个xml文件，如果未选择，默认指向default.xml
- b：选择一个maniest仓库中的一个特殊的分支
- --mirror：下一步和源同步的时候，本地按照源的版本库组织方式进行组织
- --reference=<path>：path为一个镜像地址，从镜像同步代码。
- --repo-url=<url>：url为repo 库的位置，用于修改repo文件中REPO-URL参数的指向。

命令repo init 要完成如下操作：
- 完成repo工具的完整下载，执行的repo脚本只是引导程序
- 克隆清单库manifest.git (地址来自于-u 参数)
- 克隆的清单库位于manifest.git中，克隆到本地.repo/manifests.清单.repo/manifest.xml只是符号链接，它指.repo/manifests/default.xml
- 如果manifests中有多个xml文件，repo init 可以任意选择其中一个，默认选择是default.xml

## repo sync

Usage

    repo sync [<PROJECT_LIST>]

下载新的更改并更新本地环境中的工作文件。如果您在未使用任何参数的情况下运行 repo sync，则该操作会同步所有项目的文件。
运行 repo sync 后，将出现以下情况：
- 如果目标项目从未同步过，则 repo sync 相当于 git clone。远程代码库中的所有分支都会复制到本地项目目录中。
- 如果目标项目已同步过，则 repo sync 相当于以下命令：
```
    git remote update
    git rebase origin/<BRANCH>

    其中 <BRANCH> 是本地项目目录中当前已检出的分支。如果本地分支没有在跟踪远程代码库中的分支，则相应项目不会发生任何同步。
```

- 如果 git rebase 操作导致合并冲突，那么您需要使用普通 Git 命令（例如 git rebase --continue）来解决冲突。repo sync 运行成功后，指定项目中的代码会与远程代码库中的代码保持同步。

Option:
- d：将指定项目切换回清单修订版本。如果项目当前属于某个主题分支，但只是临时需要清单修订版本，则此选项会有所帮助。
- s：同步到当前清单中清单服务器元素指定的一个已知的良好版本。
- f：即使某个项目同步失败，系统也会继续同步其他项目。

## repo start

Usage
    
    repo start <BRANCH_NAME> [<PROJECT_LIST>]

从清单中指定的修订版本开始，创建一个新的分支进行开发。
- <BRANCH_NAME> 参数应简要说明您尝试对项目进行的更改。如果您不知道，则不妨考虑使用默认名称。
- <PROJECT_LIST> 指定了将参与此主题分支的项目。

## repo diff

Usage
    
    repo diff [<PROJECT_LIST>]

使用 git diff 显示提交与工作树之间的明显更改。

## repo prune

Usage

    repo prune [<PROJECT_LIST>]

删减（删除）已合并的主题。

## repo status

Usage
    
    repo status [<PROJECT_LIST>]

对于每个指定的项目，将工作树与临时区域（索引）以及此分支 (HEAD) 上的最近一次提交进行比较。在这三种状态存在差异之处显示每个文件的摘要行。
要仅查看当前分支的状态，请运行 repo status。系统会按项目列出状态信息。对于项目中的每个文件，系统使用两个字母的代码来表示：
在第一列中，大写字母表示临时区域与上次提交状态之间的不同之处。



字母|含义|说明
------|------|------
- |  无更改 |  HEAD 与索引中相同
A |  已添加 |  不存在于 HEAD 中，但存在于索引中 
M |  已修改 |  存在于 HEAD 中，但索引中的文件已修改
D |  已删除 |  存在于 HEAD 中，但不存在于索引中
R |  已重命名  |  不存在于 HEAD 中，但索引中的文件的路径已更改
C |  已复制   |  不存在于 HEAD 中，已从索引中的另一个文件复制
T |  模式已更改|  HEAD 与索引中的内容相同，但模式已更改
U |  未合并    |  HEAD 与索引之间存在冲突；需要解决方案


在第二列中，小写字母表示工作目录与索引之间的不同之处。

  字母    |   含义       |   说明  
------|------|------
  -       |   新/未知    |   不存在于索引中，但存在于工作树中
  m       |   已修改     |   存在于索引中，也存在于工作树中（但已修改）
  d       |   已删除     |   存在于索引中，不存在于工作树中

## repo forall

Usage
    
    repo forall [<PROJECT_LIST>] -c <COMMAND>

在每个项目中运行指定的 shell 命令。通过 repo forall 可使用下列额外的环境变量：
- REPO_PROJECT 可设为项目的具有唯一性的名称。
- REPO_PATH 是客户端根目录的相对路径。
- REPO_REMOTE 是清单中远程系统的名称。
- REPO_LREV 是清单中修订版本的名称，已转换为本地跟踪分支。如果您需要将清单修订版本传递到某个本地运行的 Git 命令，则可使用此变量。
- REPO_RREV 是清单中修订版本的名称，与清单中显示的名称完全一致。

Option：
- c：要运行的命令和参数。此命令会通过 /bin/sh 进行求值，它之后的任何参数都将作为 shell 位置参数传递。
- p：在指定命令输出结果之前显示项目标头。这通过以下方式实现：将管道绑定到命令的 stdin、stdout 和 sterr 流，然后通过管道将所有输出结果传输到一个页面调度会话中显示的连续流中。
- v：显示该命令向 stderr 写入的消息。